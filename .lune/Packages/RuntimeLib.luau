--!native
--!optimize 2
local Promise = require("./Promise")
local task = require("@lune/task")

local OUTPUT_PREFIX = "roblox-ts: "

local TS = {}
TS.Promise = Promise

function TS.getModule(_context, _scope, moduleName)
	error(OUTPUT_PREFIX .. "Could not find module: " .. moduleName, 2)
end

function TS.import(_context, _module, ...)
	error("Do not use TS.import.")
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end

			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = {...}
		return Promise.new(function(resolve, reject)
			task.spawn(function()
				local ok, result = pcall(callback, table.unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)
		end)
	end
end

function TS.await(promise)
	if not Promise.Is(promise) then
		return promise
	end

	local status, value = promise:WaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

local SIGN = 2 ^ 31
local COMPLEMENT = 2 ^ 32
local function bit_sign(num)
	-- Restores the sign after an unsigned conversion according to 2s complement.
	if bit32.btest(num, SIGN) then
		return num - COMPLEMENT
	else
		return num
	end
end

function TS.bit_lrsh(a, b)
	return bit_sign(bit32.arshift(a, b))
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(func, catch, finally)
	local err, traceback
	local success, exitType, returns = xpcall(func, function(errInner)
		err = errInner
		traceback = debug.traceback()
	end)

	if not success and catch then
		local newExitType, newReturns = catch(err, traceback)
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end

	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end

	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return {done = true}
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end

				return {
					value = value;
					done = coroutine.status(co) == "dead";
				}
			end
		end;
	}
end

return TS
